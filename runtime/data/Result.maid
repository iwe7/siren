module | root vm | where

vm define-global: Result as: { Result };
let Result = {
  // -- Sub-objects ----------------------------------------------------
  def Ok
  Ok
  
  def Failure
  Failure

  // -- Constructors ---------------------------------------------------
  @Meta category: "Constructing";
  def ok: value
  Ok {
    def value = value
  }

  @Meta category: "Constructing";
  def failure: value
  Failure {
    def value = value
  }

  // -- Accessing ------------------------------------------------------
  @Meta category: "Accessing";
  def merge
  this value
};

let Ok = Result {
  // -- Monadic sequencing ---------------------------------------------
  @Meta category: "Transforming";
  def map: transformation
  let newValue = transformation call: this value;
  this { def value newValue }

  @Meta category: "Transforming";
  def chain: transformation
  transformation call: this value

  @Meta category: "Transforming";
  def match: pattern
  pattern Ok call: this value

  // -- Error handling -------------------------------------------------
  @Meta category: "Error handling";
  def recover: handler
  this

  // -- Conversions ----------------------------------------------------
  @Meta category: "Converting";
  def as-string
  "<Result ok: " + this value as-string + ">"

  @Meta category: "Converting";
  def as-array
  [this value]

  // -- Logical comparisons --------------------------------------------
  @Meta category: "Comparing and testing";
  def === aResult
  let value = this value;
  aResult match: {
    def Ok      { v | v === value }
    def Failure { v | False }
  }

  @Meta category: "Comparing and testing";
  def ok?
  True

  @Meta category: "Comparing and testing";
  def failure?
  False

  @Meta category: "Comparing and testing";
  def then: ok else: failure
  ok value

  // -- Extracting -----------------------------------------------------
  @Meta category: "Accessing";
  def get!
  this value

  @Meta category: "Accessing";
  def get-or-default: defaultValue
  this value
};

let Failure = Result {
  // -- Monadic sequencing ---------------------------------------------
  @Meta category: "Transforming";
  def map: transformation
  this

  @Meta category: "Transforming";
  def chain: transformation
  this

  @Meta category: "Transforming";
  def match: pattern
  pattern Failure call: this value

  // -- Error handling -------------------------------------------------
  @Meta category: "Error handling";
  def recover: handler
  handler call: this value

  // -- Conversions ----------------------------------------------------
  @Meta category: "Converting";
  def as-string
  "<Result failure: " + this value as-string + ">"

  @Meta category: "Converting";
  def as-array
  []

  // -- Logical comparisons --------------------------------------------
  @Meta category: "Comparing and testing";
  def === aResult
  let value = this value;
  aResult match: {
    def Ok      { v | False }
    def Failure { v | v === value }
  }

  @Meta category: "Comparing and testing";
  def ok?
  False

  @Meta category: "Comparing and testing";
  def failure?
  True

  @Meta category: "Comparing and testing";
  def then: ok else: failure
  failure value,

  // -- Extracting -----------------------------------------------------
  @Meta category: "Accessing";
  def get!
  Error panic!: "Can't extract a value from a failure. Use `merge`, `get-or-default:`, or `recover:`",

  @Meta category: "Accessing";
  def get-or-default: defaultValue
  defaultValue
}