(**********************************************************************
 *
 * This source file is part of the Siren project.
 *
 * Copyright (C) 2013-2015 Quildreen Motta.
 * Licensed under the MIT licence.
 *
 * See LICENCE for licence information.
 * See CONTRIBUTORS for the list of contributors to the project.
 *
 **********************************************************************)
module | vm | where

(*
The Core module prepares things by providing essential messages and
objects.

All objects in Siren inherit from JavaScript's Object.prototype, by
way of the `Root` object. This is so we can seamlessly work with JS
Strings, Numbers, Functions, and Arrays.
*)

vm apply-trait-globally: extend vm native-object with {
  def as-string
    (* Returns a textual representation of the object *)
    "<Object>"

  def === that
    (* Tests if two objects are equal.
    
       This compares things by reference. Specialised objects are
       expected to override this message with one that uses structural
       equality, where possible.
     *)
    vm if: (vm object: this equals?: that)
       then: True
       else: False

  def =/= that
    (* Tests if two objects are not equal. *)
    (this === that) not
  
  def does-not-understand: selector with-arguments: args
    (* This message is invoked when the runtime can not send a particular
       message to the object.

       The message is given the selector, and the original arguments used,
       and can decide what to do with it. By default, it crashes the process.
     *)
    let m1 = vm string: this as-string concat: " does not understand ";
    let m2 = vm string: m1 concat: selector;
    let m3 = vm string: m2 concat: "\nIt was given the arguments:";
    let m4 = vm string: m3 concat: args as-string;
    let m5 = vm string: m4 concat: ", but is unable to perform any computation.
Possible causes for this are:

 *  Mistyping the message name;
 *  Sending the message to the wrong object;
 *  Not importing the correct traits in the current scope.";
    vm throw: (vm error: "Does Not Understand" reason: m5)

  def clone: value
    (* Returns a copy of the object, extended with the given properties.

       This is automatically invoked when inheriting from an object, with
       the syntax `Parent { ... }`, which just expand to
       `Parent clone: { ... }`.
     *)
    vm make-object: value inheriting: this
};

(*
Root object from which all Siren objects (besides blocks) descend
*)
vm apply-trait-globally: extend Root with {
  def as-string
    (* Returns a textual representation of the object. *)
    "<Root>"
};

(*
The Unit object represents the lack of any value.

It's, in a sense, similar to `null` in other dynamic languages, however
it exclusively denotes the lack of a value (as a result of an effect) in
Siren, and is not used for signaling failures. Failures are handled
through the [[Result]] object in Siren.
*)
vm define-global: "Unit" as: { Unit };

let Unit = {
  def as-string
    (* Returns a textual representation of the object. *)
    "<Unit>"
};

(*
It doesn't make sense to clone some objects in Siren. Things like
boolean values should be unique in the whole system. To support
these cases, Siren defines a `Singleton` object, which one
can inherit to have this guarantee in their object.

Of course, one can always override the `clone:` message in
their objects themselves, as well, [[Singleton]] just makes
that job easier.
*)
vm define-global: "Singleton" as: { Singleton };

let Singleton = {
  def clone: anything
    this
};

(*
Comparisons between objects return an `Ordering` value.

In other languages, this is usually a number. By constraining
the possible values of [[Ordering]] it's much easier to test
and ensure that programs behave correctly.
*)
vm define-global: "Ordering" as: { Ordering };
let Ordering = Singleton {
  def less-than    = Less-Than
  def greater-than = Greater-Than
  def equal        = Equal
};

let Less-Than = Singleton {
  def match: pattern
    pattern less-than
};

let Greater-Than = Singleton {
  def match: pattern
    pattern greater-than
};

let Equal = Singleton {
  def match: pattern
    pattern equal
}


(*
Sometimes you want to define an interface in an object, but don't have a
concrete implementation of a method yet (or won't have a concrete
implementation of the method). For cases, it makes sense to mark the
method as `unimplemented`.

This message on the global object does just that.
*)
vm define-global: "unimplemented" as: {
  Error panic!: "Unimplemented."
};


(* Below we define some global messages that are to be used as decorators. *)

(*
Some methods are pure, and we would like to not have to run them over and
over again, because we know there can only be one result from running it.

The `lazy` decorator can be used to transform a pure method into one that
caches the result of its computations, so it only runs the computation once.
*)
vm define-global: "lazy" as: {
  { fn | let data = vm false;
         let update = { data = fn value; data };
         { vm if: data then: data else: update value } }
};


(*
Some methods just exist to proxy the access to a particular value, but the
value has already been computed. This is similar to the `lazy` decorator,
but it evaluates the expression eagerly.
*)
vm define-global: "value" as: {
  { fn | let data = fn value;
         { data }}
}


(*
Some objects need branding, so we know what kind of object we're dealing with.
The VM supports this concept of branding through a few internal methods. Adding
a brand to an object can be thought of as a transformation of the object.
*)
vm define-global: "brand:" as: { name | { object |
  let brand = vm brand/new: name;
  vm brand/attach: brand to: object;
  object
}}