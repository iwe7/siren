#-----------------------------------------------------------------------
# 
# This source file is part of the Siren project.
#
# Copyright (C) 2013-2015 Quildreen Motta.
# Licensed under the MIT licence.
#
# See LICENCE for licence information.
# See CONTRIBUTORS for the list of contributors to the project.
#
#-----------------------------------------------------------------------
$siren/1
module | vm | where


# -- Blocks ------------------------------------------------------------
vm extend: Nullary-Block with: {
  def self try
    vm try: { Result ok: self value }
       recover: { e | Result failure: (vm text: (vm object: e at: "message")) }.

  def self while: predicate
    vm while: { (predicate value) then: { vm true } else: { vm false } }
       do: self.
    Unit.
}.


# -- Modules -----------------------------------------------------------
vm extend: Importer with: {
  def self siren: id
    self siren: id with-arguments: [].
}.


# -- Branding ----------------------------------------------------------
let Branding = {
  def self traits {
    def_ Brand = Brand.
    def_ Object-Branding = Object-Branding.
  }

  def self for: object
    self traits Object-Branding { def_ object = object }
}.

vm extend: Root with: {
  def_ Branding = Branding.
}.

vm extend: Brand with: {
  def self describe
    Debug-Text,
    "<Brand: ", self description, ">".

  def self description
    "Root-Brand".

  def self with-description: description
    self { def _ description = description }.

  def self === brand
    vm if: (vm refeq: self and: brand)
       then: True
       else: False.
    
  def self is: brand
    vm if: (vm branding/brand: self is: brand)
       then: True
       else: False.
}.

vm extend: Object-Branding with: {
  def self describe
    Debug-Text,
    "<Branding for: ", self object describe, ">".

  def self has?: brand
    vm if: (vm branding/object: self object has: brand)
       then: True
       else: False.

  def self attach!: brand
    vm branding/object: self object attach: brand.
    self.

  def self remove!: brand
    vm branding/object: self object remove: brand.
    self.
}.


# -- Unit --------------------------------------------------------------
let Unit = {
  def self describe
    Debug-Text,
    "<Unit>".

  def self refined-by: _ in: _
    self.

  def self refined-by: _
    self.

  def self extended-by: _ in: _
    self.

  def self extended-by: _
    self.
}.

vm extend: Root with: {
  def_ Unit = Unit.
}.


# -- Exceptions --------------------------------------------------------
let Exception = {
  def self name = "Exception".

  def self name: name
    self { def_ name = name }.

  def self raise!: reason
    vm throw: (vm error: self name message: reason).
}.

let Unimplemented = Exception name: "<Unimplemented>".
let Message-Send-Failure = Exception name: "<Message Send Failure>".

vm extend: Root with: {
  def_ Exception = Exception.
  def_ Unimplemented = Unimplemented.
  def_ Message-Send-Failure = Message-Send-Failure.
}.

# -- Traits support ----------------------------------------------------
let Traits = {}.

vm extend: Root with: {
  def_ traits = Traits.
}.


# -- Utility decorators / messages -------------------------------------
vm extend: Root with: {
  def_ unimplemented
    Unimplemented raise!: "unimplemented".

  def_ lazy { fn |
    let computed = Reference new: False.
    let data = Reference new: Unit.
    let update = { o a | data set!: (fn in: o apply: a). computed set!: True }.
    Method {
      def self in: object apply: args = data.
        computed then: { data value }
                 else: { update call: object with: args. data value. }

      def self in: object                         = self in: object apply: [].
      def self in: object call: a                 = self in: object apply: [a].
      def self in: object call: a with: b         = self in: object apply: [a. b].
      def self in: object call: a with: b with: c = self in: object apply: [a. b. c].
    }.
  }

  def_ value { fn |
    let data = fn in: Unit apply: [].
    Method {
      def self in: _ apply: _ = data.
      def self in: _ = data.
      def self in: _ call: _ = data.
      def self in: _ call: _ with: _ = data.
      def self in: _ call: _ with: _ with: _ = data.
    }.
  }

  def_ brand: brand { object |
    (Branding for: object) attach!: brand.
    object.
  }

  def_ mixin: mixin { object |
    let o2 = object refined-by: {}.
    vm extend: o2 with: mixin.
    o2
  }

  def_ required { method |
    @inherit-meta: method
    let expectation = Method {
      def self in: object apply: _
        let mirror      = Mirror reflect: method.
        let object-name = Mirror reflect: object; meta name; get-or-default: "(Anonymous object)".
        let method-name = mirror meta name get-or-default: "(Anonymous method)".
        let signature   = mirror meta signature get-or-default: method-name.

        Message-Send-Failure raise!:
          object-name, " does not define `", method-name, "`. ",
          "You must either refine ", object-name, " and provide ",
          "the missing message, or mix it in another object that ",
          "defines this message. ", object-name, " cannot be used ",
          "directly.\n",
          "\n",
          "## Example:\n\n",
          "    Old-Object { ", signature, " = ... }.",
          "\n\n",
          "Or:\n\n",
          "    @mixin: Old-Object\n",
          "    let New-Object = { ", signature, " = ... }.".

      def self in: object                         = self in: object apply: [].
      def self in: object call: a                 = self in: object apply: [a].
      def self in: object call: a with: b         = self in: object apply: [a. b].
      def self in: object call: a with: b with: c = self in: object apply: [a. b. c].
    }.
    Mirror reflect: expectation; meta; at: "expectation.unfulfilled" put: True.
    expectation
  }
}