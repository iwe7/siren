(**********************************************************************
 *
 * This source file is part of the Siren project.
 *
 * Copyright (C) 2013-2015 Quildreen Motta.
 * Licensed under the MIT licence.
 *
 * See LICENCE for licence information.
 * See CONTRIBUTORS for the list of contributors to the project.
 *
 **********************************************************************)
module | vm | where

vm define-global: "Tuple" as: { vm native-array };

vm apply-trait-globally: extend Tuple with {
  def this as-string
    "[" + (this join: ", ") + "]"

  (* Constructing *)
  def this empty
    []

  (* Testing *)
  def this empty?
    this length === 0
  
  (* Accessing *)
  def this at: index
    ((index > 1) && (index <= this length))
      then: { Result failure: "Index " + index as-string
                            + " out of range [1, " + this length as-string + "]" }
      else: { Result ok: (vm array: this at: index) }

  def this at!: index
    this at: index >> get!

  def this first
    this at: 1

  def this first!
    this first get!

  def this last
    this at: this length

  def this last!
    this last get!

  (* Collection operations *)
  def this length
    vm array/length: this

  def this + that
    vm array: this concat: that

  def this index-of: value
    let index = vm array: this index-of: value;
    (index === 0) then: { Result failure: "Not found." }
                  else: { Result ok: index }

  def this find: value
    this index-of: value >> map: (this at: _)
                
  def this last-index-of: value
    let index = vm array: this last-index-of: value;
    (index === 0) then: { Result failure: "Not found." }
                  else: { Result ok: index }

  def this join: separator
    vm array: (this map: _ as-string) join: separator

  (* Iteration *)
  def this each: computation
    vm array: this each: { a | computation call: a };
    this

  def this map: computation
    vm array: this map: { a | computation call: a }

  def this filter: predicate
    vm array: this filter: { a | (predicate call: a) then: { vm true } else: { vm false } }

  def this fold: f from: initial
    vm array: this reduce: { a b | f call: a with: b } from: initial

  def this fold-right: f from: initial
    vm array: this reduce-right: { a b | f call: a with: b } from: initial
  
  (* Mutation *)
  def this reverse
    vm array/reverse: (vm array/shallow-copy: this)

  def this sort-by: comparator
    vm array: (vm array/shallow-copy: this) sort: { left right |
      comparator call: left with: right >> match: {
        def _ less-than    = -1
        def _ equal        =  0
        def _ greater-than =  1
      }
    }
  
};

vm foreign/convert: Tuple as: { a | a map: (FFI export: _) }