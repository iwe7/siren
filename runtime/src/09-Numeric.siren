(**********************************************************************
 *
 * This source file is part of the Siren project.
 *
 * Copyright (C) 2013-2015 Quildreen Motta.
 * Licensed under the MIT licence.
 *
 * See LICENCE for licence information.
 * See CONTRIBUTORS for the list of contributors to the project.
 *
 **********************************************************************)
module | vm | where
(*
The Numeric library provides definitions for the numeric tower in
Siren. Right now it only differentiates between Integers, which
are represented with arbitrary precision, and Floats, which use
JavaScript's native 64-bit floating point numbers.
*)

vm define-global: "Integer" as: { vm native-integer };

vm apply-trait-globally: extend Integer with {
  def this as-string
    (* Returns a textual representation of the integer. *)
    vm int/to-string: this

  def this as-float
    (* Converts to a regular float.

       This is a lossy convertion. *)
    vm int/to-number: this

  (* Ranges *)
  def this .. end
    Range from: this to: end

  def this ... end
    Range from: this to: end + 1

  (* Arithmetic *)
  def this negated
    vm int/neg: this

  def this + that
    vm int/plus: this and: that

  def this - that
    vm int/sub: this and: that

  def this * that
    vm int/mul: this and: that

  def this ** that
    vm int/pow: this and: that

  def this / that
    vm int/div: this and: that

  def this modulus: that
    vm int/mod: this and: that

  (* Bitwise *)
  def this bit-shift-right: that
    vm int/shift-right: this by: that

  def this bit-shift-left: that
    vm int/shift-left: this by: that

  def this unsigned-bit-shift-right: that
    this bit-shift-right: that >> absolute

  def this bit-and: that
    vm int/band: this and: that

  def this bit-or: that
    vm int/bor: this and: that

  def this bit-xor: that
    vm int/bxor: this and: that

  (* Maths *)
  def this square-root
    vm int/sqrt: this

  (* Rounding / Converting *)
  def this absolute
    vm int/abs: this

  def this round
    this

  def this ceil
    this

  def this floor
    this

  (* Logical comparisons *)
  def this === that
    vm if: (vm int/eq: this and: that)
       then: True
       else: False

  def this > that
    vm if: (vm int/gt: this and: that)
       then: True else: False

  def this >= that
    vm if: (vm int/ge: this and: that)
       then: True else: False

  def this < that
    vm if: (vm int/lt: this and: that)
       then: True else: False

  def this <= that
    vm if: (vm int/le: this and: that)
       then: True else: False
};

vm foreign/convert: Integer as: { a | a };


vm define-global: "Float" as: { vm native-float };

(* Native numbers just use Float64 *)
vm apply-trait-globally: extend Float with {
  (* Constants *)
  def this max-value
    vm float/max-value

  def this min-value
    vm float/min-value

  def this nan
    vm float/nan

  def this negative-infinity
    vm float/-infinity

  def this positive-infinity
    vm float/+infinity

  (* Tests *)
  def this nan?
    vm if: (vm float/nan?: this)
       then: True
       else: False

  def this finite?
    vm if: (vm float/finite?: this)
       then: True
       else: False

  (* Logical comparisons *)
  def this === that
    vm if: (vm float: this equals?: that)
       then: True
       else: False

  def this =/= that
    vm if: (vm float: this not-equals?: that)
       then: True
       else: False

  def this > that
    vm if: (vm float: this greater?: that)
       then: True
       else: False

  def this >= that
    vm if: (vm float: this greater-or-equal?: that)
       then: True
       else: False

  def this < that
    vm if: (vm float: this less-than?: that)
       then: True
       else: False

  def this <= that
    vm if: (vm float: this less-than-or-equal?: that)
       then: True
       else: False

  (* Conversions *)
  def this as-exponential
    vm float/as-exponential: this

  def this as-fixed
    vm float/as-fixed: this

  def this as-locale-string
    vm float/as-locale-string: this

  def this as-string
    vm float/as-string: this

  (* Ranges *)
  def this .. end
    Range from: this to: end

  def this ... end
    Range from: this to: end + 1
  
  (* Arithmetic *)
  def this + that
    vm float: this plus: that

  def this - that
    vm float: this minus: that

  def this * that
    vm float: this times: that

  def this ** that
    vm float: this power: that

  def this / that
    vm float: this div: that

  def this modulus: that
    vm float: this modulus: that

  (* Bitwise *)
  def this bit-shift-right: that
    vm float: this bit-shift-right: that

  def this bit-shift-left: that
    vm float: this bit-shift-left: that

  def this unsigned-bit-shift-right: that
    vm float: this unsigned-bit-shift-right: that

  def this bit-or: that
    vm float: this bit-or: that

  def this bit-and: that
    vm float: this bit-and: that

  def this bit-xor: that
    vm float: this bit-xor: that

  (* Geometry *)
  def this arc-cosine
    vm float/arccosine: this

  def this arc-sine
    vm float/arcsine: this

  def this arc-tangent
    vm float/arctangent: this

  def this arc-tangent: that
    vm float: this arctangent: that

  def this cosine
    vm float/cosine: this

  def this sine
    vm float/sine: this

  def this tangent
    vm float/tangent: this
  
  (* Maths/etc *)
  def this exp
    vm float/exp: this

  def this log
    vm float/log: this

  def this square-root
    vm float/square-root: this
  
  (* Rounding / Converting *)
  def this absolute
    vm float/absolute: this

  def this round
    vm float/round: this

  def this ceil
    vm float/ceil: this

  def this floor
    vm float/floor: this
};

vm foreign/convert: Float as: { a | a }