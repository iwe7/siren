#-----------------------------------------------------------------------
# 
# This source file is part of the Siren project.
#
# Copyright (C) 2013-2015 Quildreen Motta.
# Licensed under the MIT licence.
#
# See LICENCE for licence information.
# See CONTRIBUTORS for the list of contributors to the project.
#
#-----------------------------------------------------------------------
$siren/1
module | vm | where

vm extend: Root with: {
  def_ Mirror = Mirror.
}.

let Mirror = {
  def self describe
    Debug-Text, "<Mirror>".

  def_ traits {
    def_ Object-Mirror = Object-Mirror.
    def_ Meta-Mirror = Meta-Mirror.
  }

  def self reflect: object context: context
    self traits Object-Mirror {
      def_ reflectee = object.
      def_ reflectee-context = context.
    }.

  def self reflect: object
    self reflect: object context: vm global-context
}.

let Object-Mirror = Mirror {
  def self describe
    Debug-Text, "<Object-Mirror on: ", self reflectee describe, " context: ", self reflectee-context describe, ">".

  def self meta
    self traits Meta-Mirror {
      def_ reflectee = self reflectee.
    }.

  def self methods
    let xs = vm reflect/methods: self reflectee context: self reflectee-context.
    xs map: { pair | pair first! => pair last! }.

  def self selector-from-name: name
    vm assert/text: name.
    let selector = vm reflect/method-selector: name
                      on: self reflectee
                      in: self reflectee-context.
    vm if: (vm failed?: selector)
       then: { Result failure: "No such method: ", name }
       else: { Result ok: selector };
       value.

  def self method-for-name: name do {
    selector <- self selector-from-name: name.
    self method-for-selector: selector.
  }

  def self method-for-selector: selector
    vm assert/selector: selector.
    let result = vm reflect/method-for-selector: selector on: self reflectee.
    vm if: (vm failed?: result)
       then: { Result failure: "No such method: ", selector description }
       else: { Result ok: result };
       value.

  def self responds-to?: name
    (self method-for-name: name) then: { True } else: { False }.

  def self parent
    let result = vm reflect/parent: self reflectee.
    vm if: (vm failed?: result)
       then: { Result failure: "No parent." }
       else: { Result ok: result };
       value.

  def self is: object
    vm if: vm refeq: self reflectee and: object
       then: True else: False.
}.

let Meta-Mirror = {
  def_ traits {
    def_ Source-Location = Source-Location.
  }

  def self describe
    Debug-Text, "<Meta-Mirror on: ", self reflectee describe, ">".

  def self at: name
    vm assert/text: name.
    let result = vm meta: self reflectee at: name.
    vm if: (vm failed?: result)
       then: { Result failure: "No meta-data ", name }
       else: { Result ok: result };
       value.

  def self at: name put: value
    vm assert/text: name.
    vm meta: self reflectee at: name put: value.
    self.

  def self name
    self at: "name".

  def self name: name
    vm assert/text: name.
    self at: "name" put: name.

  def self arguments
    self at: "arguments".

  def self arguments: args
    vm assert/tuple: args.
    self at: "arguments" put: args.

  def self source
    self traits Source-Location {
      def_ code      = self at: "source".
      def_ start     = self at: "start-offset".
      def_ end       = self at: "end-offset".
      def_ filename  = self at: "filename".
    }.

  def self source: source
    source code map: { code | self at: "source" put: code }.
    source start map: { n | self at: "start-offset" put: n }.
    source end map: { n | self at: "end-offset" put: n }.
    source filename map: { name | self at: "filename" put: name }.

  def self category
    self at: "category".

  def self category: category
    vm assert/text: category.
    self at: "category" put: category.

  def self tags
    self at: "tags".

  def self tags: tags
    vm assert/tuple: tags.
    self at: "tags" put: tags.

  def self documentation
    self at: "documentation".

  def self documentation: docs
    vm assert/text: docs.
    self at: "documentation" put: docs.

  def self examples
    self at: "examples".

  def self examples: examples
    vm assert/tuple: examples.
    self at: "examples" put: examples.
}.

let Source-Location = {
  def self describe
    Debug-Text,
    "<Source-Location(", self start describe, ", ", self end describe, "): ", self filename describe, ">".

  def self source: code
    self { def_ source = code }.

  def self start: n
    vm assert/numeric: n.
    self { def_ start = n }.

  def self end: n
    vm assert/numeric: n.
    self { def_ end = n }.

  def self filename: name
    self { def_ filename = name }.
}.

vm extend: Root with: {
  def_ name: name { object |
    Mirror reflect: object; meta; name: name.
    object.
  }

  def_ category: category { object |
    Mirror reflect: object; meta; category: category.
    object.
  }

  def_ tags: tags { object |
    Mirror reflect: object; meta; tags: tags.
    object.
  }

  def_ documentation: docs { object |
    Mirror reflect: object; meta; documentation: docs.
    object.
  }

  def_ examples: examples { object |
    Mirror reflect: object; meta; examples: examples.
    object.
  }

  def_ example: example { object |
    let meta = Mirror reflect: object; meta.
    let examples = meta examples get-or-default: [].
    meta examples: examples, [example].
    object.
  }
}.

